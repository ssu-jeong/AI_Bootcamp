# 03. 성능분석 기법

---

## a. 자료구조와 알고리즘

---

### 자료구조와 알고리즘의 관계

---

자료구조는 **자료를 구성하고 접근하는 체계적인 방법**
알고리즘은 **어떤 일을 수행하는 일련의 과정이자 단계적인 절차**

우리가 학습하려는 자료구조는 단순히 구조만이 아닌 **양질의 알고리즘과 효율성을 가진 데이터 구조!!**

## b. 성능 분석의 기준

---

### 양질의 자료구조와 알고리즘을 구분하는 기준

---

양질을 판단하는 대표적 척도는 **실행시간(Running time)**
자료구조의 연산, 알고리즘이 수행하는 절차에서 **효율성**과 **메모리 사용 크기(공간)**에 관심을 가져야함!

추가로 **데이터의 개수와 크기에 따라 어떻게 실행시간이 바뀌는 지에 대한 관계도**를 고려

### 시간 복잡도와 공간 복잡도

---

최적의 알고리즘은 시간 복잡도와 공간 복잡도로 분석한 결과가 좋다는 뜻

- 시간 복잡도(time complexity) : '속도'에 관한 분석 결과

- 공간 복잡도(space complexity) : '메모리 사용량'에 대한 분석 결과

   - 메모리에 대해서는 외부적 요인(하드웨어 부품 개발 등)으로 개선되거나 비교 대상이 메모리에 대해서는 동일한 조건일 경우가 많고, 시간 복잡도와 공간복잡도를 동시에 사용하여 판단하기 어려워 일반적으로 **'속도'**에 집중.

## c. 속도 기준 알고리즘 비교

---

### 속도로 분석하는 과정

---

1. 연산 횟수 세기ㅣ

2. 1과 처리해야 되는 데이터 수에 대한 관계를 분석

3. 2를 통해 관계식(또는 함수)T(n)을 세운다

### 최악의 상황 분석

---

복잡한 동전 지갑에서 눈을 가리고 500원 찾기

1. 최선: 첫 동전 부터 500원

2. 평균: 반절정도 꺼냈을 때 500원 발견

3. 최악: 500원은 없었다..

알고리즘을 분석할 때 **최악의 경우(Worst Case)**으로 상황을 둔다.

- **발생 빈도가 높은 평균의 경우(Average Case)를 성능 분석한 결과**가 더 필요

### 처리 데이터가 많은 상황 분석

---

처리할 데이터의 개수에 따라 연산 횟수가 급격하게 늘어나서 알고리즘의 속도가 느려질 수 있다.

![image](https://wikidocs.net/images/page/34789/03%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_%EA%B4%91%EA%B3%84%EB%8F%84.png)

보통 알고리즘은 하나 구현하며 데이터가 적을 때 이득은 적은 편이지만 데이터가 많을 때의 손해는 큼

   - 따라서 **알고리즘 B가 A보다 좋다**고 평가 하지만 프로그램 특성상 처리할 데이터가 적거나, 두 알고리즘이 만나는 지점보다 적은 데이터만 관리한다면 A를 사용해야 한다. 

## d. 시간 복잡도 계산과 빅오(Big-Oh) 표기법

---

### 알고리즘 분석에 인정되는 연산

---

연산 횟수에 카운트 되는 **기본 연산**

- 변수에 값을 배정

- 함수 호출

- 산술연산

- 비교연산

- 인덱싱을 이용한 코드

- 반환(return)

- 참조 또는 내부 속성 접근

### 시간 복잡도 T(n)계산

---

만일 n개의 데이터에서 각각 기본연산 3번씩 한다?
-> T(n) = n * 3 = 3n

### 빅오(Big-Oh) 표기법

---

정확한 시간복잡도를 구하는게 어려운 상황에 가장 차수가 높은것만 남겨 놓아 비교하는 것(높음 n이 처리할 데이터가 많을 수록 그 차이가 크기 때문)

T(n) = n^5 + n^3 + n + 5 => O(n) = n^5

빅오 표기법은 식을 단순화하는 것보다 "알고리즘을 수행시간에 따른 성능 기준을 나누기 쉽다"에 의미
정확한 식을 모르더라도 "이 알고리즘의 성능은 여기 정도다"라고 판단가능.

- O(1) : 상수시간(Constant Time)

- O(logn) : 로그시간 또는 대수시간(Logarithmic)

- O(n) : 선형시간(Linear)

- O(nlogn) : 로그선형시간(Log-Linear)

- O(n^2) : 제곱시간(Quadratic)

- O(n^3) : 세제곱시간(Cubic)

- O(2^n) : 지수시간(Exponential)

[직접그래프그리기](https://www.desmos.com/calculator)

![image](https://wikidocs.net/images/page/34790/03%ED%95%A8%EC%88%98%EC%A6%9D%EA%B0%80%EC%9C%A8.png)

2^n을 제외하면 초반부에 O(n)보다 더 좋은 성능처럼 그래프에 나오지만, 실제로 데이터 처리는 개수가 1부터 시작이므로 의미가 없다.

![image](https://wikidocs.net/images/page/34790/03%ED%95%A8%EC%88%98%EC%A6%9D%EA%B0%80%EC%9C%A8_1%EC%9D%B4%ED%95%98.png)

