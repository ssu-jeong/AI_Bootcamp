### 얕은 복사(shallow copy)와 깊은 복사(deep copy)

#### mutable / immutable

- mutable : 변경가능한 객체 -> list, dict, set 

```python
# 값이 변경되어도 id는 변함 없다.

#List
a = [1,2]         #a = [1,2]
id(a)
>>> 1985209849032

a.append(3)       #a = [1,2,3]
id(a)
>>> 1985209849032

#Dict
a = {1:'a'}       #a = {1:'a'}
id(a)
>>> 1985209931096

a[2] = 'b'        #a = {1:'a', 2:'b'}
id(a)
>>> 1985209931096

""" 
mutable 에 속한 객체들은 값이 변경이 일어날떄 객체의 값이 변경된다.
"""
#List
a = [1,2]
b = a             #b = [1,2]
a == b            #a = [1,2] , b = [1,2]
>>> True

b.append(3)       #b = [1,2,3]
a == b            #a = [1,2,3] , b = [1,2,3]
>>> True

#Dict
a = {1:'a'}
b = a             #b = {1:'a'}
a == b            #a = {1:'a'} , b = {1:'a'}
>>> True

b[2] = 'b'        #b = {1:'a',2:'b'}
a == b            #a = {1:'a',2:'b'} , b = {1:'a',2:'b'}
>>> True

"""
mutable 객체들은 값의 변경이 일어날떄 주소가 참조하는 값이 모두 변경된다.
"""
```

- immutable : 변경불가능한 객체 -> int, str, tuple

```python
"""
a 변수에 첫번째 글자를 변경 시도하면 에러가 발생한다.
a에 다른 값을 할당하면 id가 변경된다.

재할당은 애초에 변수를 다시 할당하는 것으로 mutable과 immutable과는 다른 문제!!
mutable인 list도 값을 재할당하면 id가 변경된다. 
"""

#Int
a = 1                 #1
id(a)
>>> 140729439544144

a += 1            #2
id(a)
>>> 140729439544176

#String
a = 'a'               #a
id(a)
>>> 1985199052704

a += 'b'          #ab
id(a)
>>> 1985209620944

#Tuple
a = (1,2)         #(1,2)
id(a)
>>> 1985209935624

a += (3,)         #(1,2,3)
id(a)
>>> 1985209858448

"""
immutable 에 속한 객체들은 값이 변경이될떄 객체가 변한다.
"""
```

```python
#Int
a = 1
b = a             #b = 1
a == b            #a = 1 , b = 1
>>> True

b += 1            #b = 2
a == b            #a = 1 , b = 2
>>> False

#String
a = 'a'
b = a             #b = 'a'
a == b            #a = 'a' , b = 'a'
>>> True

b += 'b'          #b = 'ab'
a == b            #a = 'a' , b = 'ab'
>>> False

#Tuple
a = (1,2)
b = a             #b = (1,2)
a == b            #a = (1,2) , b = (1,2)
>>> True

b += (3,)         #b = (1,2,3)
a == b            #a = (1,2) , b = (1,2,3)
>>> False

""" 
immutable 객체들은 값이 변경되는것이 새로운 객체로생성이 되기떄문에 변경이 일어날떄 기존 객체는 변하하지 않는다.
"""
```

#### 변수 간 대입

- mutable한 객체의 변수 간 대입

**list의 얕은 복사**
b 에 a를 할당하면 값이 할당되는 것이 아니라 **같은 메모리 주소**를 바라본다.
b를 변경하면 같이 a도 바뀐다.
mutable한 다른 객체 또한 똑같은 현상이 나타난다.

```python
a = [1, 2, 3]
b = a # shallow copy
b[0]= 5
a
>>> [5, 2, 3]

b
>>> [5, 2, 3]

id(a)
>>> 4396179528

id(b)
>>> 4396179528
```

- immutable한 객체의 변수간 대입

**str 문자열의 얕은 복사**
list와 똑같이 b를 a에 할당하면 같은 메모리 주소를 바라보게 된다.
하지만 b에 다른 값을 할당하면 **재할당**이 이루어지며 **메모리 주소가 변경**된다.
고로 a와 b는 다른 값을 가진다.

```python
a = "abc"
b = a
a
>>> 'abc'

b
>>> 'abc'

id(a)
>>> 4387454680

id(b)
>>> 4387454680

b = "abcd"
a
>>> 'abc'

b
>>> 'abcd'

id(a)
>>> 4387454680

id(b)
>>> 4396456400
```

#### 얕은 복사(shallow copy)
list의 슬라이싱을 통한 새로운 통한 새로운 값을 할당한다.
아래의 결과와 같이 슬라이싱을 통해서 값을 할당하면 **새로운 id**가 부여되며 서로 영향을 받지 않는다. 

```python
a = [1,2,3]
b = a[:]
id(a)
>>> 4396179528

id(b)
>>> 4393788808

a == b
>>> True

a is b
>>> False

b[0] = 5
a
>>> [1, 2, 3]
b
>>> [5, 2, 3]
```

하지만, 이러한 슬라이싱 또한 얕은 복사에 해당한다.
리스트안에 리스트 mutable 객체 안에 mutable 객체인 경우 문제.
id(a) 값과 id(b) 값은 다르게 되었지만, 그 내부의 객체 id(a[0])과 id(b[0])은 같은 주소를 바라보고 있다.

```python
a = [[1,2], [3,4]]
b = a[:]
id(a)
4395624328
id(b)
4396179592
id(a[0])
4396116040
id(b[0])
4396116040

#재할당 하는 경우는 문제가 없다. 메모리 주소도 변경
a[0] = [8,9]
a
>>> [[8, 9], [3, 4]]
b
>>> [[1, 2], [3, 4]]

id(a[0])
>>> 4393788808
id(b[0])
>>> 4396116040

# a[1]에 값을 변경하면 b[1]도 따라 변경
a[1].append(5)
a
>>> [[8, 9], [3, 4, 5]]
b
>>> [[1, 2], [3, 4, 5]]

id(a[1])
>>> 4396389896
id(b[1])
>>> 4396389896

#copy 모듈의 copy 메소드 또한 얕은 복사
import copy
a = [[1,2],[3,4]]
b = copy.copy(a)
a[1].append(5)
a
>>> [[1, 2], [3, 4, 5]]
b
>>> [[1, 2], [3, 4, 5]]
```

#### 깊은 복사(deep copy)

깊은 복사는 내부에 객체들까지 모두 새롭게 copy

```python
#copy.deepcopy메소드가 해결
import copy
a = [[1,2],[3,4]]
b = copy.deepcopy(a)
a[1].append(5)
a
>>> [[1, 2], [3, 4, 5]]
b
>>> [[1, 2], [3, 4]]
```

[참고](https://velog.io/@aonee/Python-%EC%9E%90%EB%A3%8C%ED%98%95%EC%9D%98-%EA%B0%92-%EC%A0%80%EC%9E%A5-%EB%B3%B5%EC%82%AC-copy)